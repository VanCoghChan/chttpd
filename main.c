// Created by N on 2023/12/21.#include<unistd.h>#include<arpa/inet.h>#include<string.h>#include <pthread.h>#include <fcntl.h>#include <openssl/ssl.h>#include "cc.h"#include "cchttpd.h"// 初始化sslSSL_CTX *init_ssl(){    SSL_CTX *ctx;    // 初始化ssl库    SSL_library_init();    // 加载所有ssl算法    OpenSSL_add_all_algorithms();    // 加载所有ssl错误信息    SSL_load_error_strings();    // 创建ssl上下文    ctx = SSL_CTX_new(SSLv23_server_method());    if (ctx == NULL){        PRINTF("SSL_CTX_new error\n", get_time_str());        exit(1);    }    // 加载证书    if (SSL_CTX_use_certificate_file(ctx, "./keys/cnlab.cert", SSL_FILETYPE_PEM) <= 0){        PRINTF("SSL_CTX_use_certificate_file error\n", get_time_str());        exit(1);    }    // 加载私钥    if (SSL_CTX_use_PrivateKey_file(ctx, "./keys/cnlab.prikey", SSL_FILETYPE_PEM) <= 0){        PRINTF("SSL_CTX_use_PrivateKey_file error\n", get_time_str());        exit(1);    }    // 检查私钥是否正确    if (!SSL_CTX_check_private_key(ctx)){        PRINTF("SSL_CTX_check_private_key error\n", get_time_str());        exit(1);    }    return ctx;}int main(void){    // 切换工作目录为上层目录    chdir("..");    unsigned short port_80 = 80, port_443 = 443;    int server_sock_80 = start_server(&port_80);    int server_sock_443 = start_server(&port_443);    printf("http Server started on port %d...\n", port_80);    printf("https Server started on port %d...\n", port_443);    struct sockaddr_in client_addr;    int client_addr_len = sizeof(client_addr);    int maxfd;    // 设置socket为非阻塞    fcntl(server_sock_80, F_SETFL, O_NONBLOCK);    fcntl(server_sock_443, F_SETFL, O_NONBLOCK);    maxfd = server_sock_80 > server_sock_443 ? server_sock_80 : server_sock_443;    while (1) {        fd_set readfds;        FD_ZERO(&readfds);        FD_SET(server_sock_80, &readfds);        FD_SET(server_sock_443, &readfds);        int ret = select(maxfd + 1, &readfds, NULL, NULL, NULL);        if (ret < 0) {            printf("select error\n");            continue;        }        if (FD_ISSET(server_sock_80, &readfds)) {            // 有新的连接请求(http)            int client_sock_80 = accept(                    server_sock_80,                    (struct sockaddr *) &client_addr,                    &client_addr_len                    );            // 设置socket为非阻塞            fcntl(client_sock_80, F_SETFL, O_NONBLOCK);            maxfd = client_sock_80 > maxfd ? client_sock_80 : maxfd;            // 使用client_sock与客户端通信,使用多线程处理多个服务请求            // 创建一个新的线程，用于监听80端口（http）            pthread_t thread;            pthread_create(&thread, NULL, handle_request_80, &client_sock_80);            pthread_detach(thread);        }        if (FD_ISSET(server_sock_443, &readfds)) {            // 有新的连接请求(https)            int client_sock_443 = accept(                    server_sock_443,                    (struct sockaddr *) &client_addr,                    &client_addr_len                    );            // 设置socket为非阻塞            fcntl(client_sock_443, F_SETFL, O_NONBLOCK);            maxfd = client_sock_443 > maxfd ? client_sock_443 : maxfd;            // 新建一个线程，用于监听443端口（https）            pthread_t thread2;            pthread_create(&thread2, NULL, handle_request_443, &client_sock_443);            pthread_detach(thread2);        }    }    // close server socket    close(server_sock_80);    return 0;}